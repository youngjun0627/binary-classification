# -*- coding: utf-8 -*-
"""model_uchan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CAhHrMA3Pg403szXpku4vABuSNnooMyA
"""

import torch
import torch.nn as nn
import torchvision.models as models
import timm

class build_model(nn.Module):
    def __init__(self, num_classes=1):
        super().__init__()
        model = timm.create_model('efficientnet_b3', pretrained=False, in_chans=3)
        num_features = model.num_features
        model = nn.Sequential(*(list(model.children())[:-1]))
        model.add_module('fc1', nn.Linear(num_features, 256))
        model.add_module('dropout1', nn.Dropout(0.5))

        model.add_module('fc2', nn.Linear(256, 64))
        model.add_module('dropout2', nn.Dropout(0.5))

        model.add_module('fc3', nn.Linear(64, num_classes))
        model.add_module('sigmoid', nn.Sigmoid())

        #newmodel = nn.Sequential(*list(model.children())[:-2])
        #newmodel.add_module('1x1 convolution', nn.Conv2d(model.num_features, 256,1))
        #newmodel.add_module('pooling', (list(model.children())[-2]))
        #newmodel.add_module('dropout', nn.Dropout(0.5))
        #newmodel.add_module('linear1', nn.Linear(256,num_classes))

        self.model = model

    def forward(self, x):
        return self.model(x)


class build_newmodel(nn.Module):
    def __init__(self, num_classes=1):
        super().__init__()
        model = timm.create_model('efficientnet_b4', pretrained=False, in_chans=3)
        num_features = model.num_features
        model = nn.Sequential(*(list(model.children())[:-1]))
        model.add_module('fc1', nn.Linear(num_features, 512))
        model.add_module('dropout1', nn.Dropout(0.5))

        model.add_module('fc2', nn.Linear(512, 256))
        model.add_module('dropout2', nn.Dropout(0.5))

        model.add_module('fc3', nn.Linear(256, 64))
        model.add_module('dropout3', nn.Dropout(0.5))

        model.add_module('fc4', nn.Linear(64, num_classes))
        model.add_module('sigmoid', nn.Sigmoid())

        #newmodel = nn.Sequential(*list(model.children())[:-2])
        #newmodel.add_module('1x1 convolution', nn.Conv2d(model.num_features, 256,1))
        #newmodel.add_module('pooling', (list(model.children())[-2]))
        #newmodel.add_module('dropout', nn.Dropout(0.5))
        #newmodel.add_module('linear1', nn.Linear(256,num_classes))

        self.model = model

    def forward(self, x):
        return self.model(x)

class build_newmodel2(nn.Module):
    def __init__(self, num_classes=3):
        super().__init__()
        model = timm.create_model('efficientnet_b4', pretrained=False, in_chans=3)
        num_features = model.num_features
        model = nn.Sequential(*(list(model.children())[:-1]))
        model.add_module('fc1', nn.Linear(num_features, 512))
        model.add_module('dropout1', nn.Dropout(0.5))

        model.add_module('fc2', nn.Linear(512, 256))
        model.add_module('dropout2', nn.Dropout(0.5))

        model.add_module('fc3', nn.Linear(256, 64))
        model.add_module('dropout3', nn.Dropout(0.5))

        model.add_module('fc4', nn.Linear(64, num_classes))

        #newmodel = nn.Sequential(*list(model.children())[:-2])
        #newmodel.add_module('1x1 convolution', nn.Conv2d(model.num_features, 256,1))
        #newmodel.add_module('pooling', (list(model.children())[-2]))
        #newmodel.add_module('dropout', nn.Dropout(0.5))
        #newmodel.add_module('linear1', nn.Linear(256,num_classes))

        self.model = model

    def forward(self, x):
        return self.model(x)

class build_jaydenmodel(nn.Module):
    def __init__(self, num_classes=1):
        super().__init__()
        model = timm.create_model('efficientnet_b1', pretrained=False, num_classes = 256, in_chans=3)
        model = nn.Sequential(*(list(model.children())[:]))
        model.add_module('dropout',nn.Dropout(0.5))

        model.add_module('fc1', nn.Linear(256, 64))
        model.add_module('dropout1', nn.Dropout(0.5))

        model.add_module('fc2', nn.Linear(64, num_classes))

        model.add_module('sigmoid', nn.Sigmoid())

        #newmodel = nn.Sequential(*list(model.children())[:-2])
        #newmodel.add_module('1x1 convolution', nn.Conv2d(model.num_features, 256,1))
        #newmodel.add_module('pooling', (list(model.children())[-2]))
        #newmodel.add_module('dropout', nn.Dropout(0.5))
        #newmodel.add_module('linear1', nn.Linear(256,num_classes))

        self.model = model

    def forward(self, x):
        return self.model(x)

class build_uchanmodel(nn.Module):
    def __init__(self, num_classes=1):
        super().__init__()
        model = timm.create_model('efficientnet_b0', pretrained=False, num_classes=256, in_chans=3)
        num_features = model.num_features
        model = nn.Sequential(*(list(model.children())[:-1]))

        self.dropout = nn.Dropout(0.5)
        self.dropouts = nn.ModuleList([nn.Dropout(0.5) for _ in range(5)])
        self.output1_layer = nn.Linear(num_features,256)
        self.output2_layer = nn.Linear(256,num_classes)
        self.sigmoid = nn.Sigmoid()


        #newmodel = nn.Sequential(*list(model.children())[:-2])
        #newmodel.add_module('1x1 convolution', nn.Conv2d(model.num_features, 256,1))
        #newmodel.add_module('pooling', (list(model.children())[-2]))
        #newmodel.add_module('dropout', nn.Dropout(0.5))
        #newmodel.add_module('linear1', nn.Linear(256,num_classes))

        self.model = model

    def forward(self, x):
        out = self.model(x)
        out = self.output1_layer(out)

        for i, dropout in enumerate(self.dropouts):
            if i==0:
                output = self.output2_layer(dropout(out))
            else:
                output += self.output2_layer(dropout(out))
        else:
            output /= len(self.dropouts)
        output = self.sigmoid(output)
        return output